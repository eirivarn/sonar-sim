"""Volumetric sonar simulation using ray marching.

OVERVIEW:
---------
The VoxelSonar class simulates forward-looking sonar using volumetric ray marching.
Unlike traditional surface-based raycasting, this approach accumulates returns
from the entire volume, producing realistic sonar imagery with proper shadowing,
volume scattering, and acoustic artifacts.

SOMAR PARAMETERS:
----------------
- range_m: Maximum range in meters (e.g., 20m)
- fov_deg: Field of view in degrees (e.g., 120Â°)
- num_beams: Number of angular samples (e.g., 256)
- range_bins: Number of range samples (e.g., 512)

These define the polar image resolution: (range_bins, num_beams)

RAY MARCHING ALGORITHM:
----------------------
For each beam:
1. Calculate beam direction from sonar orientation + beam angle
2. Apply beam pattern (Gaussian falloff at edges)
3. March ray through voxel grid in small steps (step_size = voxel_size * factor)
4. At each step:
   a. Read voxel properties (density, reflectivity, absorption)
   b. Calculate scattered energy: energy * density * reflectivity * step_size
   c. Apply propagation losses (spreading, water absorption)
   d. Deposit return in appropriate range bin (with jitter/spreading)
   e. Reduce forward energy (absorption + scattering)
5. Stop when energy drops below threshold or range exceeded

REALISTIC ACOUSTIC EFFECTS:
--------------------------
The simulation includes multiple noise sources for realism:

1. ACOUSTIC SPECKLE:
   - Multiplicative noise from coherent interference
   - Gamma distribution: speckle = Gamma(shape=2.5, scale=1/2.5)
   - Makes uniform surfaces look grainy/mottled

2. SPATIAL JITTER:
   - Range measurement uncertainty
   - Randomly shifts returns to nearby range bins
   - Creates "freckled" appearance with position errors
   - Increases with range: jitter_std = base * (1 + range/max_range)

3. MULTI-BIN SPREADING:
   - Some returns spread across multiple range bins
   - Simulates volume backscatter and reverberation
   - Probability-based: ~15% of returns spread to 2-5 bins

4. ASPECT ANGLE VARIATION:
   - Return strength varies with small orientation changes
   - Simulates micro-scale surface roughness
   - Random multiplier: 0.5 + 0.3*randn(), clipped to [0.2, 1.5]

5. TEMPORAL DECORRELATION:
   - Frame-to-frame variability
   - Simulates net sway, water movement, fish motion
   - Applied globally: image *= Gamma(shape, scale)
   - Creates continuous flickering/shimmering

6. BEAM PATTERN:
   - Gaussian falloff toward FOV edges
   - Weaker returns at beam periphery
   - pattern = exp(-((angle / half_fov)^2) * falloff)

7. GEOMETRIC SHADOWING:
   - Energy budget depletes as ray passes through material
   - Objects in front cast acoustic shadows behind them
   - energy *= exp(-absorption * distance) * (1 - scattering_loss)

GROUND TRUTH GENERATION:
-----------------------
When return_ground_truth=True, scan() returns two images:
1. Sonar image: Realistic with all noise effects
2. Ground truth map: Clean material IDs at each (range, beam) pixel

Ground truth is generated by:
- Sampling material_id from voxel grid along each ray
- No noise, no accumulation - just nearest material
- Used for training semantic segmentation models

PROPAGATION LOSSES:
------------------
1. Spreading loss: 1 / (range^2 + min_dist)
   - Two-way path: out and back
   - Prevents division by zero at origin
   
2. Water absorption: exp(-alpha * 2 * range)
   - Frequency-dependent in real sonar (assumed here)
   - Two-way path doubles the loss
   
3. Material absorption: exp(-absorption * step_size)
   - Local energy loss when passing through material
   - Creates dark shadows behind dense objects

CONTROL METHODS:
---------------
- move(delta): Translate sonar position
- rotate(angle_deg): Rotate sonar direction

These are typically called from keyboard controls in visualization.py

USAGE EXAMPLE:
-------------
    sonar = VoxelSonar(
        position=np.array([15.0, 25.0]),
        direction=np.array([0.0, -1.0]),  # Looking up
        range_m=20.0,
        fov_deg=120.0,
        num_beams=256
    )
    
    sonar_image, ground_truth = sonar.scan(grid, return_ground_truth=True)
    # sonar_image: (512, 256) float array with acoustic returns
    # ground_truth: (512, 256) uint8 array with material IDs

RELATIONSHIP TO OTHER MODULES:
-----------------------------
- voxel_grid.py: Provides material properties at each position
- config.py: SONAR_CONFIG controls all noise/physics parameters
- visualization.py: Displays sonar image and handles user controls
- scenes/*.py: Provide scene geometry for sonar to scan

TUNING PARAMETERS:
-----------------
All noise and physics parameters are in config.py under SONAR_CONFIG.
Adjust these to change sonar characteristics:
- Increase speckle_shape for cleaner images (less noise)
- Increase jitter_probability for more spatial uncertainty
- Increase temporal_decorrelation_shape for less flickering
- Adjust beam_pattern_falloff for sharper/softer FOV edges
"""
import numpy as np
from src.config import SONAR_CONFIG
from src.core.voxel_grid import VoxelGrid

# Try to import numba-accelerated functions, fall back to pure Python if not available
try:
    from src.core.sonar_numba import scan_parallel_numba, compute_ground_truth_numba
    NUMBA_AVAILABLE = True
except ImportError:
    NUMBA_AVAILABLE = False
    import warnings
    warnings.warn("Numba not available - simulation will be slow. Install numba: pip install numba", RuntimeWarning)


class VoxelSonar:
    """Sonar using voxel ray marching."""
    
    def __init__(self, position: np.ndarray, direction: np.ndarray,
                 range_m: float = None, fov_deg: float = None, num_beams: int = None):
        """Initialize sonar.
        
        Args:
            position: Sonar position in world (meters)
            direction: Forward direction (normalized)
            range_m: Maximum range (default from config)
            fov_deg: Field of view in degrees (default from config)
            num_beams: Number of beams (default from config)
        """
        self.position = position.copy()
        self.direction = direction / (np.linalg.norm(direction) + 1e-9)
        self.range_m = range_m if range_m is not None else SONAR_CONFIG['range_m']
        self.fov_deg = fov_deg if fov_deg is not None else SONAR_CONFIG['fov_deg']
        self.num_beams = num_beams if num_beams is not None else SONAR_CONFIG['num_beams']
        self.range_bins = SONAR_CONFIG['range_bins']
    
    def scan(self, grid: VoxelGrid, return_ground_truth: bool = True):
        """Scan scene using volumetric ray marching.
        
        Args:
            return_ground_truth: If True, also return ground truth material ID map
        
        Returns:
            If return_ground_truth is False:
                (range_bins, num_beams) array of accumulated returns
            If return_ground_truth is True:
                Tuple of (sonar_image, ground_truth_map) both (range_bins, num_beams)
        """
        # Use Numba-accelerated version if available
        if NUMBA_AVAILABLE:
            return self._scan_numba(grid, return_ground_truth)
        else:
            return self._scan_python(grid, return_ground_truth)
    
    def _scan_numba(self, grid: VoxelGrid, return_ground_truth: bool = True):
        """Numba-accelerated scan."""
        fov_rad = np.deg2rad(self.fov_deg)
        
        # Compute ground truth if needed
        ground_truth = None
        if return_ground_truth:
            ground_truth = compute_ground_truth_numba(
                grid.material_id, grid.size_x, grid.size_y, grid.voxel_size,
                self.position[0], self.position[1], self.direction[0], self.direction[1],
                self.range_m, self.range_bins, self.num_beams, fov_rad
            )
        
        # Parallel ray marching for sonar image
        image = scan_parallel_numba(
            grid.density, grid.reflectivity, grid.absorption, grid.material_id,
            grid.size_x, grid.size_y, grid.voxel_size,
            self.position[0], self.position[1], self.direction[0], self.direction[1],
            self.range_m, self.range_bins, self.num_beams, fov_rad,
            SONAR_CONFIG['beam_pattern_falloff'],
            SONAR_CONFIG['step_size_factor'],
            SONAR_CONFIG['energy_threshold'],
            SONAR_CONFIG['speckle_shape'],
            SONAR_CONFIG['aspect_variation_std'],
            SONAR_CONFIG['aspect_variation_range'][0],
            SONAR_CONFIG['aspect_variation_range'][1],
            SONAR_CONFIG['spreading_loss_min'],
            SONAR_CONFIG['water_absorption'],
            SONAR_CONFIG['jitter_probability'],
            SONAR_CONFIG['jitter_std_base'],
            SONAR_CONFIG['jitter_range_factor'],
            SONAR_CONFIG['jitter_max_offset'],
            SONAR_CONFIG['spread_probability'],
            np.array(SONAR_CONFIG['spread_bin_options'], dtype=np.int32),
            np.array(SONAR_CONFIG['spread_bin_probs'], dtype=np.float64),
            SONAR_CONFIG['absorption_factor'],
            SONAR_CONFIG['scattering_loss_factor'],
            SONAR_CONFIG['angle_scatter_strength'],
            SONAR_CONFIG['angle_scatter_power'],
            SONAR_CONFIG['density_scatter_threshold'],
            SONAR_CONFIG['density_scatter_strength'],
            SONAR_CONFIG['density_noise_boost'],
            SONAR_CONFIG['proximity_shadow_strength'],
            SONAR_CONFIG['proximity_shadow_max_distance']
        )
        
        # TEMPORAL DECORRELATION
        signal_mask = image > 1e-8
        decorr_shape = SONAR_CONFIG['temporal_decorrelation_shape']
        decorrelation_noise = np.random.gamma(shape=decorr_shape, scale=1.0/decorr_shape, size=image.shape)
        image[signal_mask] *= decorrelation_noise[signal_mask]
        
        # GROUPED SCATTERING: Coherent noise patches (adjacent beams scatter together)
        if SONAR_CONFIG['grouped_scatter_enabled']:
            group_prob = SONAR_CONFIG['grouped_scatter_probability']
            group_width = SONAR_CONFIG['grouped_scatter_width']
            coherence = SONAR_CONFIG['grouped_scatter_coherence']
            scatter_strength = SONAR_CONFIG['grouped_scatter_strength']
            additive_prob = SONAR_CONFIG['grouped_scatter_additive_prob']
            disappear_prob = SONAR_CONFIG['grouped_scatter_disappear_prob']
            additive_boost = SONAR_CONFIG['grouped_scatter_additive_boost']
            
            groups_applied = 0
            # Scan through beams and occasionally apply grouped scattering
            beam_idx = 0
            while beam_idx < self.num_beams:
                if np.random.rand() < group_prob and image[:, beam_idx].max() > 1e-6:
                    # Find a range bin with signal in this beam
                    signal_bins = np.where(image[:, beam_idx] > 1e-6)[0]
                    if len(signal_bins) > 0:
                        # Pick a random signal bin to scatter around
                        center_bin = np.random.choice(signal_bins)
                        
                        # Determine scatter mode for this group
                        mode_rand = np.random.rand()
                        if mode_rand < disappear_prob:
                            scatter_mode = 'disappear'
                        elif mode_rand < disappear_prob + additive_prob:
                            scatter_mode = 'additive'
                        else:
                            scatter_mode = 'multiply'
                        
                        # Generate base scatter pattern (use config strength)
                        base_scatter = np.random.randn(group_width) * scatter_strength
                        
                        # Apply to adjacent beams
                        for offset in range(group_width):
                            beam_target = beam_idx + offset
                            if beam_target >= self.num_beams:
                                break
                            
                            # Mix coherent group scatter with independent noise
                            coherent_scatter = base_scatter[offset]
                            independent_scatter = np.random.randn() * scatter_strength
                            mixed_scatter = coherence * coherent_scatter + (1 - coherence) * independent_scatter
                            
                            # Apply to a larger range patch around center_bin
                            patch_size = np.random.randint(8, 20)  # Much larger patches (was 3-8)
                            for r_offset in range(-patch_size//2, patch_size//2 + 1):
                                r_idx = center_bin + r_offset
                                if 0 <= r_idx < self.range_bins and image[r_idx, beam_target] > 1e-6:
                                    if scatter_mode == 'disappear':
                                        # Zero out or heavily attenuate
                                        image[r_idx, beam_target] *= np.random.uniform(0.0, 0.2)
                                    elif scatter_mode == 'additive':
                                        # Add energy (creates bright spots)
                                        scatter_mult = 1.0 + abs(mixed_scatter) * additive_boost
                                        scatter_mult = np.clip(scatter_mult, 1.0, 5.0)
                                        image[r_idx, beam_target] *= scatter_mult
                                    else:
                                        # Normal multiplicative scatter
                                        scatter_mult = 1.0 + mixed_scatter
                                        scatter_mult = np.clip(scatter_mult, 0.1, 4.0)
                                        image[r_idx, beam_target] *= scatter_mult
                        
                        groups_applied += 1
                        # Skip past this group
                        beam_idx += group_width
                    else:
                        beam_idx += 1
                else:
                    beam_idx += 1
            
            if groups_applied > 0:
                print(f"Applied {groups_applied} grouped scatter patches")
        
        # AZIMUTH STREAKING: Localized range-slice saturation from excessive returns
        if SONAR_CONFIG['azimuth_streak_enabled']:
            # Calculate total energy per range bin (across all azimuths)
            range_energy = np.sum(image, axis=1)
            max_energy = np.max(range_energy) if np.max(range_energy) > 0 else 1.0
            
            # Identify range bins with high energy
            threshold = SONAR_CONFIG['azimuth_streak_threshold'] * max_energy
            high_energy_ranges = range_energy > threshold
            
            num_high = np.sum(high_energy_ranges)
            if num_high > 0:
                print(f"Found {num_high} high-energy range bins (threshold={threshold:.2f}, max={max_energy:.2f})")
            
            # Apply streaking with some probability
            streak_prob = SONAR_CONFIG['azimuth_streak_probability']
            streak_strength = SONAR_CONFIG['azimuth_streak_strength']
            streak_width = SONAR_CONFIG['azimuth_streak_width']  # Localized width
            
            streaks_applied = 0
            for r_idx in np.where(high_energy_ranges)[0]:
                if np.random.rand() < streak_prob:
                    # Pick a random azimuth center for the localized streak
                    streak_center = np.random.randint(0, self.num_beams)
                    
                    # Apply much stronger gain adjustment to a localized azimuth range
                    # Can be either gain reduction (saturation) or boost (AGC overcompensation)
                    gain_adjust = 1.0 + (np.random.rand() - 0.5) * 2 * streak_strength
                    gain_adjust = np.clip(gain_adjust, 0.1, 3.0)  # Much more extreme (was 0.4-1.8)
                    
                    # Apply to localized beam range
                    beam_start = max(0, streak_center - streak_width // 2)
                    beam_end = min(self.num_beams, streak_center + streak_width // 2)
                    image[r_idx, beam_start:beam_end] *= gain_adjust
                    streaks_applied += 1
            
            if streaks_applied > 0:
                print(f"Applied {streaks_applied} azimuth streaks")
        
        # INTENSITY GAIN: Apply calibration to match real sonar levels
        image *= SONAR_CONFIG['intensity_gain']
        
        if return_ground_truth:
            return image, ground_truth
        else:
            return image
    
    def _scan_python(self, grid: VoxelGrid, return_ground_truth: bool = True):
        """Pure Python scan (fallback when Numba not available)."""
        image = np.zeros((self.range_bins, self.num_beams), dtype=np.float32)
        ground_truth = np.zeros((self.range_bins, self.num_beams), dtype=np.uint8) if return_ground_truth else None
        
        # Pre-compute ground truth by sampling world at each (range, angle)
        if return_ground_truth:
            fov_rad = np.deg2rad(self.fov_deg)
            for beam_idx in range(self.num_beams):
                # Beam direction
                t = beam_idx / (self.num_beams - 1) if self.num_beams > 1 else 0.5
                angle = (-fov_rad / 2) + t * fov_rad
                
                # Rotate direction by angle
                dir_angle = np.arctan2(self.direction[1], self.direction[0])
                beam_angle = dir_angle + angle
                beam_dir = np.array([np.cos(beam_angle), np.sin(beam_angle)])
                
                # Sample material at each range along this beam
                for range_idx in range(self.range_bins):
                    distance = (range_idx / self.range_bins) * self.range_m
                    world_pos = self.position + beam_dir * distance
                    
                    # Get material at this world position
                    vx, vy = grid.world_to_voxel(world_pos)
                    if grid.is_inside(vx, vy):
                        ground_truth[range_idx, beam_idx] = grid.material_id[vx, vy]
        
        fov_rad = np.deg2rad(self.fov_deg)
        
        for beam_idx in range(self.num_beams):
            # Beam direction
            t = beam_idx / (self.num_beams - 1) if self.num_beams > 1 else 0.5
            angle = (-fov_rad / 2) + t * fov_rad
            
            # BEAM PATTERN: Gaussian falloff toward edges
            beam_pattern = np.exp(-((angle / (fov_rad/2))**2) * SONAR_CONFIG['beam_pattern_falloff'])
            
            # Rotate direction by angle
            dir_angle = np.arctan2(self.direction[1], self.direction[0])
            beam_angle = dir_angle + angle
            beam_dir = np.array([np.cos(beam_angle), np.sin(beam_angle)])
            
            # Ray march through volume (for sonar image only)
            self._march_ray(grid, self.position, beam_dir, image[:, beam_idx], beam_pattern)
        
        # TEMPORAL DECORRELATION: Additional frame-to-frame variability on objects only
        signal_mask = image > 1e-8
        decorr_shape = SONAR_CONFIG['temporal_decorrelation_shape']
        decorrelation_noise = np.random.gamma(shape=decorr_shape, scale=1.0/decorr_shape, size=image.shape)
        image[signal_mask] *= decorrelation_noise[signal_mask]
        
        # INTENSITY GAIN: Apply calibration to match real sonar levels
        image *= SONAR_CONFIG['intensity_gain']
        
        if return_ground_truth:
            return image, ground_truth
        else:
            return image
    
    def _march_ray(self, grid: VoxelGrid, origin: np.ndarray, direction: np.ndarray,
                   output_bins: np.ndarray, beam_strength: float = 1.0):
        """March ray through voxel grid, accumulating returns.
        
        Args:
            beam_strength: Beam pattern multiplier (1.0 at center, lower at edges)
        """
        # DDA-style voxel traversal
        step_size = grid.voxel_size * SONAR_CONFIG['step_size_factor']
        num_steps = int(self.range_m / step_size)
        
        current_pos = origin.copy()
        energy = 1.0  # Energy budget
        energy_threshold = SONAR_CONFIG['energy_threshold']
        
        for step in range(num_steps):
            distance = step * step_size
            if distance >= self.range_m or energy < energy_threshold:
                break
            
            # Get voxel properties at current position
            x, y = grid.world_to_voxel(current_pos)
            
            if not grid.is_inside(x, y):
                current_pos += direction * step_size
                continue
            
            density = grid.density[x, y]
            reflectivity = grid.reflectivity[x, y]
            absorption = grid.absorption[x, y]
            
            # VOLUME SCATTERING: Deposit return proportional to density and reflectivity
            if density > 0.05:  # Higher threshold filters weak background voxels
                # ACOUSTIC SPECKLE: Multiplicative noise from coherent interference
                speckle_shape = SONAR_CONFIG['speckle_shape']
                speckle = np.random.gamma(shape=speckle_shape, scale=1.0/speckle_shape)
                
                # ASPECT ANGLE VARIATION: Return strength varies with small angle changes
                aspect_std = SONAR_CONFIG['aspect_variation_std']
                aspect_range = SONAR_CONFIG['aspect_variation_range']
                aspect_variation = 0.5 + aspect_std * np.random.randn()
                aspect_variation = np.clip(aspect_variation, aspect_range[0], aspect_range[1])
                
                # GEOMETRIC SHADOWING: Objects in front block energy to objects behind
                scatter = energy * density * reflectivity * step_size * speckle * aspect_variation
                
                # Two-way propagation loss
                spreading_loss = 1.0 / (distance**2 + SONAR_CONFIG['spreading_loss_min'])
                water_abs = SONAR_CONFIG['water_absorption']
                water_absorption = np.exp(-0.05 * distance * 2 * water_abs)  # Two-way
                
                return_energy = scatter * spreading_loss * water_absorption
                
                # SPATIAL JITTER: Echo position uncertainty for freckled appearance
                bin_idx = int((distance / self.range_m) * (len(output_bins) - 1))
                
                jitter_prob = SONAR_CONFIG['jitter_probability']
                if np.random.rand() < jitter_prob:
                    # Random Gaussian jitter with range-dependent degradation
                    range_factor = 1.0 + (distance / self.range_m) * SONAR_CONFIG['jitter_range_factor']
                    jitter_offset = int(np.round(np.random.randn() * SONAR_CONFIG['jitter_std_base'] * range_factor))
                    jitter_offset = np.clip(jitter_offset, -SONAR_CONFIG['jitter_max_offset'], SONAR_CONFIG['jitter_max_offset'])
                    bin_jitter = bin_idx + jitter_offset
                    bin_jitter = np.clip(bin_jitter, 0, len(output_bins) - 1)
                else:
                    bin_jitter = bin_idx
                
                # MULTI-BIN SPREADING: Sometimes deposit return across multiple adjacent bins
                spread_prob = SONAR_CONFIG['spread_probability']
                if np.random.rand() < spread_prob:
                    # Spread across multiple bins
                    num_spread_bins = np.random.choice(
                        SONAR_CONFIG['spread_bin_options'], 
                        p=SONAR_CONFIG['spread_bin_probs']
                    )
                    spread_center = bin_jitter
                    
                    for offset in range(-(num_spread_bins//2), (num_spread_bins//2) + 1):
                        spread_bin = spread_center + offset
                        if 0 <= spread_bin < len(output_bins):
                            # Energy falls off from center of spread (Gaussian-ish)
                            spread_weight = np.exp(-0.5 * (offset / (num_spread_bins/3))**2)
                            range_quality = 1.0 / (1.0 + (distance / self.range_m) * 0.8)
                            output_bins[spread_bin] += return_energy * beam_strength * range_quality * spread_weight / num_spread_bins
                else:
                    # Single bin deposit
                    if 0 <= bin_jitter < len(output_bins):
                        range_quality = 1.0 / (1.0 + (distance / self.range_m) * 0.8)
                        output_bins[bin_jitter] += return_energy * beam_strength * range_quality
            
            # ABSORPTION: Reduce forward energy (creates shadows)
            if density > 0.05:  # Higher threshold filters weak background voxels
                # Both absorption and scattering reduce forward energy
                energy *= np.exp(-absorption * step_size * SONAR_CONFIG['absorption_factor'])
                energy *= (1.0 - density * reflectivity * step_size * SONAR_CONFIG['scattering_loss_factor'])
                energy = max(0.0, energy)
            
            # Move forward
            current_pos += direction * step_size
    
    def move(self, delta: np.ndarray):
        """Move sonar position."""
        self.position += delta
    
    def rotate(self, angle_deg: float):
        """Rotate sonar."""
        angle_rad = np.deg2rad(angle_deg)
        cos_a = np.cos(angle_rad)
        sin_a = np.sin(angle_rad)
        
        self.direction = np.array([
            self.direction[0] * cos_a - self.direction[1] * sin_a,
            self.direction[0] * sin_a + self.direction[1] * cos_a
        ])
